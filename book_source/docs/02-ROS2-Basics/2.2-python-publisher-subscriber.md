## 2.2 Python Publisher and Subscriber Examples: Your First ROS 2 Communication

This section is dedicated to hands-on Python examples, guiding you through the creation of your first ROS 2 nodes: a publisher and a subscriber. These practical exercises will solidify your understanding of the fundamental publish-subscribe communication model, an essential skill for building any robotic application. You'll learn how to set up, code, and execute these nodes, and how to verify their communication.

### 2.2.1 Setting Up Your ROS 2 Workspace (Important Pre-requisite)

Before diving into the code, ensure your ROS 2 environment is correctly set up. If you haven't already, follow these steps in your terminal:

1.  **Create a ROS 2 Workspace:** A workspace is a directory where you develop your ROS 2 packages.
    ```bash
    mkdir -p ~/ros2_ws/src
    cd ~/ros2_ws
    ```
2.  **Initialize the Workspace:**
    ```bash
    rosdep install -i --from-path src --rosdistro humble -y
    colcon build --symlink-install
    ```
    *   `rosdep install`: Installs system dependencies for your packages.
    *   `colcon build`: The build tool for ROS 2. `--symlink-install` creates symbolic links, which is convenient for development as you don't need to rebuild after every code change.
3.  **Source the Workspace:** This adds your workspace's packages to your ROS 2 environment.
    ```bash
    source install/setup.bash
    ```
    *   **Pro Tip:** Add this `source` command to your `~/.bashrc` (or `~/.zshrc`) file to automatically source your workspace every time you open a new terminal. This is crucial for avoiding common "command not found" errors.

4.  **Create a ROS 2 Package:** A package is the fundamental unit of organization in ROS 2, containing your nodes, message definitions, and other related files.
    ```bash
    cd src
    ros2 pkg create --build-type ament_python my_robot_pkg
    cd ..
    ```
    *   `--build-type ament_python`: Specifies that this is a Python package, using the `ament` build system.
    *   This creates a directory structure like `~/ros2_ws/src/my_robot_pkg/my_robot_pkg/` and `~/ros2_ws/src/my_robot_pkg/setup.py`.

Now you're ready to create your publisher and subscriber nodes within the `my_robot_pkg` package.

### 2.2.2 Python Publisher Example: The "Hello World" Broadcaster

Let's create a simple ROS 2 node in Python that continuously publishes a "Hello World" message to a designated topic. This example demonstrates how to set up a basic publisher node, including its initialization, message creation, and publishing loop.

**File Location:** `~/ros2_ws/src/my_robot_pkg/my_robot_pkg/hello_publisher.py`

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String # Standard ROS 2 message type for strings

class HelloWorldPublisher(Node):
    def __init__(self):
        # Initialize the node with a unique name
        # The name 'hello_world_publisher_node' will appear in 'ros2 node list'
        super().__init__('hello_world_publisher_node')

        # Create a publisher
        # It will send String messages to the topic named 'hello_topic'
        # The queue size (10) determines how many messages to buffer if subscribers are slow
        self.publisher_ = self.create_publisher(String, 'hello_topic', 10)

        # Set a timer to call the timer_callback function repeatedly
        # This function will be called every 0.5 seconds (2 Hz)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

        self.message_counter = 0  # Counter for messages to make them unique
        self.get_logger().info('Hello World Publisher Node Started!')

    def timer_callback(self):
        # Create a new String message object
        msg = String()
        msg.data = f'Hello from ROS 2! Message Count: {self.message_counter}'

        # Publish the message to the 'hello_topic'
        self.publisher_.publish(msg)

        # Log the published message to the console
        self.get_logger().info(f'Published: "{msg.data}" (Sequence: {self.message_counter})')

        self.message_counter += 1

def main(args=None):
    # Initialize the ROS 2 Python client library
    rclpy.init(args=args)

    # Create an instance of our publisher node
    hello_publisher_node = HelloWorldPublisher()

    # Spin the node, allowing it to process callbacks (like our timer_callback)
    # This keeps the node alive and publishing until Ctrl+C is pressed
    try:
        rclpy.spin(hello_publisher_node)
    except KeyboardInterrupt: # Handle Ctrl+C gracefully
        pass

    # Destroy the node cleanly once rclpy.spin() returns
    hello_publisher_node.destroy_node()
    # Shut down the ROS 2 Python client library
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### 2.2.2.1 Making the Publisher Executable (setup.py)

To run this Python file as a ROS 2 node, you need to tell ROS 2 about it by modifying your `setup.py` file within `~/ros2_ws/src/my_robot_pkg/`.

**File:** `~/ros2_ws/src/my_robot_pkg/setup.py`

Locate the `entry_points` dictionary and add an entry for your publisher node:

```python
from setuptools import setup

package_name = 'my_robot_pkg'

setup(
    name=package_name,
    version='0.0.0',
    packages=[package_name],
    data_files=[
        ('share/' + package_name, ['package.xml']),
        ('share/' + package_name + '/launch', ['launch/hello_world_launch.py']), # Add this for launch file later
        # ... other data files
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='your_name',
    maintainer_email='your_email@example.com',
    description='TODO: Package description',
    license='TODO: License declaration',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'hello_publisher = my_robot_pkg.hello_publisher:main',
        ],
    },
)
```

*   **Explanation:**
    *   `'hello_publisher'`: This is the command-line executable name you'll use to run your node.
    *   `my_robot_pkg.hello_publisher:main`: This tells ROS 2 to look for a Python module named `hello_publisher` inside your `my_robot_pkg` package and execute its `main()` function.

#### 2.2.2.2 Building and Running the Publisher

1.  **Build Your Package:** Navigate back to your workspace root and build.
    ```bash
    cd ~/ros2_ws
    colcon build --packages-select my_robot_pkg
    source install/setup.bash # Re-source after build
    ```
2.  **Run the Publisher Node:**
    ```bash
    ros2 run my_robot_pkg hello_publisher
    ```
    You should see messages being published to the console by your `HelloWorldPublisher` node.

3.  **Verify with ROS 2 Tools (Controls):** Open a *new* terminal (and remember to source your workspace: `cd ~/ros2_ws && source install/setup.bash`):
    *   **List active nodes:** `ros2 node list` (You should see `'/hello_world_publisher_node'`)
    *   **List active topics:** `ros2 topic list` (You should see `'/hello_topic'`)
    *   **Echo topic messages:** `ros2 topic echo /hello_topic` (This will display the messages published by your node in real-time).

### 2.2.3 Python Subscriber Example: The "Hello World" Listener

Now, let's create a corresponding subscriber node that listens to the `hello_topic` and prints the messages it receives. This demonstrates how a node can consume data published by another node.

**File Location:** `~/ros2_ws/src/my_robot_pkg/my_robot_pkg/hello_subscriber.py`

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class HelloWorldSubscriber(Node):
    def __init__(self):
        # Initialize the node with a unique name
        super().__init__('hello_world_subscriber_node')

        # Create a subscriber
        # It will listen for String messages on the topic named 'hello_topic'
        # When a message arrives, it will call the self.listener_callback function
        self.subscription = self.create_subscription(
            String,           # Message type expected
            'hello_topic',    # Topic name to subscribe to
            self.listener_callback, # Callback function to execute
            10                # Queue size
        )
        # Prevent unused variable warning
        self.subscription
        self.get_logger().info('Hello World Subscriber Node Started, waiting for messages...')

    def listener_callback(self, msg):
        # This function is called automatically every time a new message is received on 'hello_topic'
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    hello_subscriber_node = HelloWorldSubscriber()

    try:
        rclpy.spin(hello_subscriber_node)
    except KeyboardInterrupt: # Handle Ctrl+C gracefully
        pass

    hello_subscriber_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### 2.2.3.1 Making the Subscriber Executable (setup.py)

Just like the publisher, you need to add an entry for your subscriber node in `~/ros2_ws/src/my_robot_pkg/setup.py` under the `entry_points` dictionary:

```python
# ... (existing setup.py content)

    entry_points={
        'console_scripts': [
            'hello_publisher = my_robot_pkg.hello_publisher:main',
            'hello_subscriber = my_robot_pkg.hello_subscriber:main', # Add this line
        ],
    },
)
```

#### 2.2.3.2 Building and Running the Subscriber

1.  **Build Your Package:** If you modified `setup.py`, rebuild your package.
    ```bash
    cd ~/ros2_ws
    colcon build --packages-select my_robot_pkg
    source install/setup.bash # Re-source after build
    ```
2.  **Run the Subscriber Node:** Open a *new* terminal (and source your workspace):
    ```bash
    ros2 run my_robot_pkg hello_subscriber
    ```

    Now, if you have your `hello_publisher` running in another terminal, you should see the `hello_subscriber` node printing the "Hello World" messages it receives. This demonstrates a complete, albeit simple, ROS 2 communication pipeline!

### 2.2.4 Project: Simple Echo Bot (Putting it all Together)

This project challenges you to combine your knowledge of publishers and subscribers to create a more interactive ROS 2 system. You'll implement three nodes to simulate a basic chat or data processing pipeline.

**Goal:** Create a `talker`, `listener`, and `echo_bot` node that communicate using topics.

#### Project Steps:

1.  **Create `talker` node (`my_robot_pkg/talker.py`):
    *   Publishes `std_msgs/String` messages to a topic named `/chatter` at a rate of 1 Hz (or similar).
    *   The message content can be a simple phrase like "Hello ROS 2!" followed by a sequence number.
2.  **Create `listener` node (`my_robot_pkg/listener.py`):
    *   Subscribes to the `/chatter` topic.
    *   Prints every message it receives to the console.
3.  **Create `echo_bot` node (`my_robot_pkg/echo_bot.py`):
    *   Subscribes to the `/chatter` topic.
    *   When it receives a message, it modifies the `data` field (e.g., appends " - ECHOED by BOT").
    *   Publishes the modified message to a *new* topic, `/chatter_echo`.

#### Implementation Guidelines:

*   **Re-use Code Structure:** Base your `talker` and `listener` nodes on the `hello_publisher.py` and `hello_subscriber.py` examples.
*   **`echo_bot` Logic:** The `echo_bot` will have both a subscriber and a publisher within the same node class.
*   **`setup.py` Updates:** Remember to add `entry_points` for `talker`, `listener`, and `echo_bot` in your `my_robot_pkg/setup.py`.
*   **Build & Source:** After making code changes and updating `setup.py`, always `colcon build --packages-select my_robot_pkg` and `source install/setup.bash`.

#### Verification (Controls):

1.  Open three separate terminals.
2.  In each terminal, `cd ~/ros2_ws && source install/setup.bash`.
3.  Run each node in its own terminal:
    *   `ros2 run my_robot_pkg talker`
    *   `ros2 run my_robot_pkg listener`
    *   `ros2 run my_robot_pkg echo_bot`
4.  Open a *fourth* terminal and verify communication:
    *   `ros2 topic list` (You should see `/chatter` and `/chatter_echo`)
    *   `ros2 topic echo /chatter` (Shows original messages)
    *   `ros2 topic echo /chatter_echo` (Shows echoed messages)

This project provides a comprehensive practical exercise in ROS 2 node development, demonstrating both basic and chained publish-subscribe patterns.