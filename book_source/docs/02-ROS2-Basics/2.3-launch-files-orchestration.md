## 2.3 Launch Files: Orchestrating Your Robot System

As your robotic system evolves from simple publisher-subscriber pairs to a complex network of interdependent nodes, manually starting and configuring each component becomes cumbersome and error-prone. This is where **ROS 2 Launch Files** become indispensable. Launch files are powerful scripts that automate the orchestration of your entire robot system, ensuring consistency, repeatability, and efficiency in both development and deployment environments.

### 2.3.1 What are ROS 2 Launch Files?

Launch files are executable scripts (most commonly written in Python, though XML is also supported) that define how multiple ROS 2 nodes are started, configured, and managed. They provide a structured way to bring up an entire robot application or a specific subsystem with a single command.

*   **Analogy:** Think of a director orchestrating a play. Instead of telling each actor individually when to enter, what costume to wear, and where to stand, the director uses a script (the launch file) to coordinate everyone simultaneously, ensuring the entire performance flows smoothly.
*   **Key Benefits:**
    *   **Automation:** Start multiple nodes with specific settings using a single command.
    *   **Configuration Management:** Easily pass parameters to nodes, adjust their behavior, and remap topic/service names without modifying source code.
    *   **Modularity:** Include other launch files, allowing you to build complex systems from smaller, reusable components.
    *   **Reproducibility:** Ensure that your robot system starts up consistently every time, which is critical for testing, debugging, and deployment across different environments.
    *   **Conditional Logic:** Implement conditional execution to start nodes or actions only if certain criteria are met.

### 2.3.2 Core Capabilities of ROS 2 Launch Files (Basics)

Launch files offer a rich set of features to manage your ROS 2 applications effectively:

1.  **Node Execution:** The most fundamental capability is to define and execute ROS 2 nodes. You specify the package the node belongs to, its executable name, and optionally a custom name for the node in the ROS graph.
    ```python
    from launch_ros.actions import Node

    # Example of launching a node
    Node(
        package='my_robot_pkg',
        executable='my_node_executable',
        name='custom_node_name',
        output='screen', # Directs node output to the terminal
    )
    ```

2.  **Parameter Configuration:** Pass static or dynamic parameters to your nodes at startup. This is incredibly useful for tuning algorithms, setting sensor thresholds, or adjusting control gains without recompiling code.
    ```python
    # Passing parameters to a node
    Node(
        package='my_robot_pkg',
        executable='sensor_driver',
        parameters=[
            {'sensor_id': 1},
            {'calibration_offset': 0.05},
            {'publish_frequency': 10.0}
        ]
    )
    ```

3.  **Topic and Service Remapping:** Change the default names of topics or services used by nodes. This helps avoid naming conflicts when integrating different components, or allows you to redirect data flow for testing and debugging.
    ```python
    from launch.actions import DeclareLaunchArgument
    from launch.substitutions import LaunchConfiguration

    # Example of topic remapping
    Node(
        package='nav_pkg',
        executable='mapper',
        remappings=[
            ('/input_scan', '/my_robot/lidar/scan'), # Remap default /input_scan to /my_robot/lidar/scan
            ('/output_map', '/global_map')
        ]
    )
    ```

4.  **Including Other Launch Files (Modularity):** Large, complex robot systems can be broken down into smaller, more manageable subsystems (e.g., a navigation stack, a perception pipeline, a manipulation controller). You can create separate launch files for each subsystem and then include them into a main launch file.
    ```python
    from launch.actions import IncludeLaunchDescription
    from launch.launch_description_sources import PythonLaunchDescriptionSource
    import os

    # Example of including another launch file
    IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            os.path.join(get_package_share_directory('navigation_pkg'), 'launch', 'navigation.launch.py')
        ]),
        launch_arguments={'use_sim_time': 'true'}.items() # Pass arguments to the included launch file
    )
    ```

### 2.3.3 Example: Simple Python Launch File

Let's create a basic Python launch file that starts our `hello_publisher_node` and `hello_subscriber_node` from Section 2.2. This file will reside in a `launch` directory within your package.

**File:** `~/ros2_ws/src/my_robot_pkg/launch/hello_world_launch.py`

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_robot_pkg',
            executable='hello_publisher',
            name='my_custom_publisher',
            output='screen',
            # Example of passing a parameter (though hello_publisher doesn't use it yet)
            parameters=[
                {'message_prefix': 'Publisher says: '}
            ]
        ),
        Node(
            package='my_robot_pkg',
            executable='hello_subscriber',
            name='my_custom_subscriber',
            output='screen',
        )
    ])
```

#### 2.3.3.1 Updating `setup.py` for the Launch File

To make your launch file discoverable by ROS 2, you need to add an entry to the `data_files` section in your `~/ros2_ws/src/my_robot_pkg/setup.py`. If you followed Section 2.2, this line might already be there, but double-check:

```python
from setuptools import setup
import os
from glob import glob

package_name = 'my_robot_pkg'

setup(
    name=package_name,
    version='0.0.0',
    packages=[package_name],
    data_files=[
        ('share/' + package_name, ['package.xml']),
        # Add this line to make your launch files discoverable
        (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*.py'))),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='your_name',
    maintainer_email='your_email@example.com',
    description='TODO: Package description',
    license='TODO: License declaration',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'hello_publisher = my_robot_pkg.hello_publisher:main',
            'hello_subscriber = my_robot_pkg.hello_subscriber:main',
        ],
    },
)
```

#### 2.3.3.2 Building and Running the Launch File

1.  **Build Your Package:** Navigate back to your workspace root and build.
    ```bash
    cd ~/ros2_ws
    colcon build --packages-select my_robot_pkg
    source install/setup.bash # Re-source after build
    ```
2.  **Run the Launch File:**
    ```bash
    ros2 launch my_robot_pkg hello_world_launch.py
    ```
    You should now see both the publisher and subscriber nodes start and communicate, with their output displayed in the terminal where you ran the launch command.

### 2.3.4 Advanced Concepts & Controls in Launch Files (Extras)

*   **Launch Arguments:** Define arguments that can be passed to the launch file from the command line, allowing dynamic configuration.
    ```python
    from launch.actions import DeclareLaunchArgument
    from launch.substitutions import LaunchConfiguration

    def generate_launch_description():
        # Declare a launch argument
        declare_log_level_cmd = DeclareLaunchArgument(
            'log_level',
            default_value='info',
            description='Logging level for nodes'
        )

        # Use the launch argument in a node's parameters
        node_cmd = Node(
            package='my_robot_pkg',
            executable='my_node',
            parameters=[
                {'log_level': LaunchConfiguration('log_level')}
            ]
        )
        return LaunchDescription([declare_log_level_cmd, node_cmd])
    ```
    Run with: `ros2 launch my_robot_pkg my_launch.py log_level:=debug`

*   **Conditional Execution:** Use `IfCondition` and `UnlessCondition` to start nodes or execute actions only when specific criteria are met (e.g., launching a simulation node only if `use_sim_time` is true).
    ```python
    from launch.conditions import IfCondition
    from launch.substitutions import TextSubstitution

    # Conditional node launch
    Node(
        package='sim_pkg',
        executable='sim_node',
        condition=IfCondition(LaunchConfiguration('use_simulation'))
    )
    ```

*   **Group Actions:** Use `GroupAction` to apply common properties (like namespace or remappings) to a set of nodes or included launch files, keeping your launch files organized.

*   **Event Handling:** Launch files can react to events, such as a node exiting or a specific condition being met, to trigger other actions.

### 2.3.5 Project: Orchestrating an Echo System with Launch Files

Building on the "Simple Echo Bot" project from Section 2.2, create a comprehensive launch file that orchestrates all three nodes (`talker`, `listener`, `echo_bot`). This project will give you practical experience in managing complex ROS 2 applications using launch files, a critical skill for developing robust robot systems.

**Goal:** Create a single Python launch file to start and manage your `talker`, `listener`, and `echo_bot` nodes.

#### Project Steps:

1.  **Create the Launch File (`my_robot_pkg/launch/echo_system_launch.py`):
    *   Define a `generate_launch_description()` function.
    *   Inside `LaunchDescription`, include three `Node` actions, one for each of your `talker`, `listener`, and `echo_bot` executables.
2.  **Naming and Output:** Give each node a distinct `name` within the launch file (e.g., `talker_node`, `listener_node`, `echo_bot_node`) and set `output='screen'` for all of them to see their console output.
3.  **Topic Remapping (Advanced Practice):**
    *   Declare a launch argument named `chatter_topic_remap` with a default value of `'/chatter'`.
    *   Modify the `listener` node's subscription to remap its input from `/chatter` to `LaunchConfiguration('chatter_topic_remap')`.
    *   This will allow you to dynamically change the topic the listener subscribes to when launching.

#### Example Launch File Structure Hint:

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    # Declare launch arguments here if needed
    declare_chatter_topic_remap_cmd = DeclareLaunchArgument(
        'chatter_topic_remap',
        default_value='/chatter',
        description='Topic to remap chatter to'
    )

    return LaunchDescription([
        declare_chatter_topic_remap_cmd,
        Node(
            package='my_robot_pkg',
            executable='talker',
            name='talker_node',
            output='screen',
        ),
        Node(
            package='my_robot_pkg',
            executable='listener',
            name='listener_node',
            output='screen',
            remappings=[
                ('/chatter', LaunchConfiguration('chatter_topic_remap'))
            ]
        ),
        Node(
            package='my_robot_pkg',
            executable='echo_bot',
            name='echo_bot_node',
            output='screen',
        )
    ])
```

#### Verification (Controls):

1.  **Build Your Package:** Ensure your `my_robot_pkg` is built and sourced.
    ```bash
    cd ~/ros2_ws
    colcon build --packages-select my_robot_pkg
    source install/setup.bash
    ```
2.  **Launch the System:**
    ```bash
    ros2 launch my_robot_pkg echo_system_launch.py
    ```
3.  **Verify Communication (New Terminal):**
    *   `ros2 node list` (Confirm all three nodes are running)
    *   `ros2 topic list` (Confirm `/chatter` and `/chatter_echo` topics exist)
    *   `ros2 topic echo /chatter`
    *   `ros2 topic echo /chatter_echo`
4.  **Test Remapping:** Try launching with a remapped topic:
    ```bash
    ros2 launch my_robot_pkg echo_system_launch.py chatter_topic_remap:=/my_new_chatter_topic
    ```
    Then check `ros2 topic list` and `ros2 topic echo /my_new_chatter_topic`.

This project concludes your introduction to ROS 2 communication patterns, providing you with the essential tools to manage and orchestrate complex robot behaviors.