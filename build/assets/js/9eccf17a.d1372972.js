"use strict";(globalThis.webpackChunkbook_source=globalThis.webpackChunkbook_source||[]).push([[376],{5891:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Module 02 ROS2-Basics/2.1-ros2-core-concepts","title":"Chapter 2: ROS 2 Fundamentals & Core Programming","description":"Welcome to the exciting world of ROS 2 (Robot Operating System 2)! This chapter is your foundational guide to understanding and programming with ROS 2, a powerful and flexible framework essential for developing modern robot applications. ROS 2 provides a structured, modular way for various components of a robot system to communicate, coordinate, and work together seamlessly, whether your robot is simulated or physical. By the end of this chapter, you\'ll have a solid grasp of ROS 2\'s core concepts and practical experience in building basic robotic communication systems using Python.","source":"@site/docs/Module 02 ROS2-Basics/2.1-ros2-core-concepts.md","sourceDirName":"Module 02 ROS2-Basics","slug":"/Module 02 ROS2-Basics/2.1-ros2-core-concepts","permalink":"/docs/Module 02 ROS2-Basics/2.1-ros2-core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Module 02 ROS2-Basics/2.1-ros2-core-concepts.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"1.4-lab-options-hybrid-architectures","permalink":"/docs/Module 01 Hardware-Lab/1.4-lab-options-hybrid-architectures"},"next":{"title":"2.2-python-publisher-subscriber","permalink":"/docs/Module 02 ROS2-Basics/2.2-python-publisher-subscriber"}}');var o=n(4848),r=n(8453);const t={},c="Chapter 2: ROS 2 Fundamentals & Core Programming",a={},d=[{value:"2.1 ROS 2 Core Concepts: Nodes, Topics, and Services",id:"21-ros-2-core-concepts-nodes-topics-and-services",level:2},{value:"2.1.1 Nodes: The Modular Units of Computation",id:"211-nodes-the-modular-units-of-computation",level:3},{value:"2.1.2 Topics: Asynchronous Data Streams (Publish-Subscribe Model)",id:"212-topics-asynchronous-data-streams-publish-subscribe-model",level:3},{value:"2.1.3 Services: Synchronous Request-Reply Interactions (Client-Server Model)",id:"213-services-synchronous-request-reply-interactions-client-server-model",level:3},{value:"2.1.4 Beyond Basics: Actions (Goal-Based Asynchronous Tasks)",id:"214-beyond-basics-actions-goal-based-asynchronous-tasks",level:3}];function l(e){const s={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"chapter-2-ros-2-fundamentals--core-programming",children:"Chapter 2: ROS 2 Fundamentals & Core Programming"})}),"\n",(0,o.jsx)(s.p,{children:"Welcome to the exciting world of ROS 2 (Robot Operating System 2)! This chapter is your foundational guide to understanding and programming with ROS 2, a powerful and flexible framework essential for developing modern robot applications. ROS 2 provides a structured, modular way for various components of a robot system to communicate, coordinate, and work together seamlessly, whether your robot is simulated or physical. By the end of this chapter, you'll have a solid grasp of ROS 2's core concepts and practical experience in building basic robotic communication systems using Python."}),"\n",(0,o.jsx)(s.h2,{id:"21-ros-2-core-concepts-nodes-topics-and-services",children:"2.1 ROS 2 Core Concepts: Nodes, Topics, and Services"}),"\n",(0,o.jsxs)(s.p,{children:["ROS 2 builds robotic applications using a distributed, message-passing architecture. At its heart are three fundamental concepts: ",(0,o.jsx)(s.strong,{children:"Nodes"}),", ",(0,o.jsx)(s.strong,{children:"Topics"}),", and ",(0,o.jsx)(s.strong,{children:"Services"}),". Understanding these building blocks is crucial for designing, implementing, and debugging any ROS 2-based robotic system."]}),"\n",(0,o.jsx)(s.h3,{id:"211-nodes-the-modular-units-of-computation",children:"2.1.1 Nodes: The Modular Units of Computation"}),"\n",(0,o.jsxs)(s.p,{children:["In ROS 2, a ",(0,o.jsx)(s.strong,{children:"Node"})," is the smallest and most granular unit of computation. Think of a node as an independent executable program designed to perform a specific, focused task within your robot's overall system. This modular approach is a cornerstone of ROS 2, promoting reusability, maintainability, and easier debugging of complex functionalities."]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Analogy:"})," Imagine a human body. Instead of one brain trying to manage everything, you have different organs (nodes) specialized for distinct functions: eyes for vision, ears for hearing, legs for movement. Each organ performs its job and communicates with others."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Key Characteristics:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Single Responsibility:"})," Each node typically focuses on one specific function (e.g., reading sensor data, controlling a motor, performing image processing, path planning)."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Independent Execution:"})," Nodes can be started, stopped, and restarted independently without affecting the entire robot system (unless critical dependencies are broken)."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Communication:"})," Nodes interact with each other by sending and receiving messages via Topics and Services."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.strong,{children:"Practical Examples of Nodes in a Robot System:"})}),"\n",(0,o.jsx)(s.p,{children:"Consider a mobile robot equipped with a LiDAR sensor, a camera, and a differential drive base. Here are some potential nodes and their responsibilities:"}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"lidar_driver_node"})}),": Reads raw data from the LiDAR sensor and publishes it to a ",(0,o.jsx)(s.code,{children:"/scan"})," topic."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"camera_driver_node"})}),": Captures images from the camera and publishes them to a ",(0,o.jsx)(s.code,{children:"/camera/image_raw"})," topic."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"motor_controller_node"})}),": Subscribes to velocity commands (e.g., ",(0,o.jsx)(s.code,{children:"/cmd_vel"}),") and translates them into control signals for the robot's motors."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"odometry_node"})}),": Estimates the robot's position and orientation over time by processing wheel encoder data and publishes this information (e.g., to ",(0,o.jsx)(s.code,{children:"/odom"}),")."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"object_detector_node"})}),": Subscribes to camera image topics, runs an object detection AI model, and publishes the detected object locations."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"path_planner_node"})}),": Receives goal positions and sensor data, computes a safe path for the robot, and publishes velocity commands."]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.strong,{children:"Practice: Designing Nodes for a Humanoid Arm"})}),"\n",(0,o.jsx)(s.p,{children:"Imagine you are developing a ROS 2 system for a humanoid robot arm with 7 degrees of freedom, an end-effector gripper, and force sensors in each joint. List at least five potential nodes that would be part of its ROS 2 system, and briefly describe each node's responsibility. Think about what data each node might produce or consume."}),"\n",(0,o.jsx)(s.h3,{id:"212-topics-asynchronous-data-streams-publish-subscribe-model",children:"2.1.2 Topics: Asynchronous Data Streams (Publish-Subscribe Model)"}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Topics"})," are the primary mechanism for nodes to exchange data asynchronously and continuously in ROS 2. This operates on a ",(0,o.jsx)(s.strong,{children:"publish-subscribe communication model"}),", which is perfectly suited for continuous data streams and broadcasts."]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"How it Works:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["A node that generates data (e.g., a sensor driver) acts as a ",(0,o.jsx)(s.strong,{children:"publisher"}),". It creates messages of a specific type and sends them to a named topic (e.g., ",(0,o.jsx)(s.code,{children:"/sensor_readings"}),")."]}),"\n",(0,o.jsxs)(s.li,{children:["Any other node interested in that data acts as a ",(0,o.jsx)(s.strong,{children:"subscriber"}),". It declares its interest in a specific topic and message type, and automatically receives all messages published to that topic."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Decoupling:"})," Publishers and subscribers do not need to know about each other's existence. They only need to agree on the topic name and the message type. This decoupling allows for highly flexible and scalable system designs."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Message Types:"})," Messages are strongly typed in ROS 2. This means data sent over a topic must adhere to a predefined structure (e.g., ",(0,o.jsx)(s.code,{children:"std_msgs/String"}),", ",(0,o.jsx)(s.code,{children:"sensor_msgs/LaserScan"}),", ",(0,o.jsx)(s.code,{children:"geometry_msgs/Twist"}),"). This ensures data consistency and compatibility between nodes."]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.strong,{children:"Example: Real-time Sensor Data Flow"})}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"camer-node"})})," (Publisher) captures images at 30 FPS."]}),"\n",(0,o.jsxs)(s.li,{children:["It publishes each image (e.g., ",(0,o.jsx)(s.code,{children:"sensor_msgs/Image"})," message type) to the ",(0,o.jsx)(s.code,{children:"/robot/camera/image_raw"})," topic."]}),"\n",(0,o.jsxs)(s.li,{children:["An ",(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"image_viewer_node"})})," (Subscriber) listens to ",(0,o.jsx)(s.code,{children:"/robot/camera/image_raw"})," and displays the images on a screen."]}),"\n",(0,o.jsxs)(s.li,{children:["An ",(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"object_detection_node"})})," (Subscriber) also listens to ",(0,o.jsx)(s.code,{children:"/robot/camera/image_raw"}),", processes the images to find objects, and then ",(0,o.jsx)(s.em,{children:"publishes"})," its findings (e.g., ",(0,o.jsx)(s.code,{children:"vision_msgs/Detection2DArray"})," message type) to a new topic like ",(0,o.jsx)(s.code,{children:"/robot/perception/object_detections"}),"."]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:"This example demonstrates how a single data stream (camera images) can be consumed by multiple independent nodes for different purposes simultaneously."}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.strong,{children:"Controls and Best Practices for Topics:"})}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Naming Conventions:"})," Use clear, descriptive topic names (e.g., ",(0,o.jsx)(s.code,{children:"/robot_name/sensor_type/dat-name"}),"). Namespace topics to avoid conflicts, especially in multi-robot systems or complex applications."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Message Frequency:"})," Be mindful of the message publishing rate. High-frequency topics can consume significant network bandwidth and CPU resources. Use ",(0,o.jsx)(s.code,{children:"ros2 topic hz <topic_name>"})," to monitor."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Buffer Size (Queue Size):"})," When creating publishers and subscribers, you specify a queue size (e.g., ",(0,o.jsx)(s.code,{children:"10"}),"). This buffer helps manage messages if a subscriber is temporarily slower than the publisher. A larger queue can prevent message loss but might increase latency."]}),"\n"]}),"\n",(0,o.jsx)(s.h3,{id:"213-services-synchronous-request-reply-interactions-client-server-model",children:"2.1.3 Services: Synchronous Request-Reply Interactions (Client-Server Model)"}),"\n",(0,o.jsxs)(s.p,{children:["In contrast to the continuous, asynchronous nature of topics, ",(0,o.jsx)(s.strong,{children:"Services"})," provide a ",(0,o.jsx)(s.strong,{children:"synchronous request-reply communication model"})," between nodes. They are designed for one-time interactions where a client node sends a request and ",(0,o.jsx)(s.em,{children:"waits"})," for a specific response from a service server node."]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"How it Works:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["A node that offers a specific functionality (e.g., a robot action) acts as a ",(0,o.jsx)(s.strong,{children:"service server"}),". It advertises a named service (e.g., ",(0,o.jsx)(s.code,{children:"/robot/reset_pose"}),") with a defined request and response message type."]}),"\n",(0,o.jsxs)(s.li,{children:["A ",(0,o.jsx)(s.strong,{children:"client node"})," needs to perform that functionality. It makes a request to the service server and then ",(0,o.jsx)(s.em,{children:"blocks"})," (or waits asynchronously) until it receives a response."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Use Cases:"})," Services are ideal for tasks that require a direct action, a definitive result, or querying specific information at a particular moment. Examples include:","\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:'Triggering a specific robot manipulation task (e.g., "pick up object A").'}),"\n",(0,o.jsx)(s.li,{children:'Querying the current state or a parameter from another node (e.g., "what is the battery level?").'}),"\n",(0,o.jsxs)(s.li,{children:["Performing a one-shot operation that requires confirmation (e.g., ",(0,o.jsx)(s.code,{children:"reset_odometry"}),", ",(0,o.jsx)(s.code,{children:"save_map"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.strong,{children:"Example: Robot Gripper Service"})}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:["A ",(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"high_level_planner_node"})})," (Client) determines the robot needs to grasp an object."]}),"\n",(0,o.jsxs)(s.li,{children:["It calls a service on the ",(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.code,{children:"gripper_control_node"})})," (Service Server) named ",(0,o.jsx)(s.code,{children:"/robot/manipulator/grasp_object"}),"."]}),"\n",(0,o.jsxs)(s.li,{children:["The client sends a request message (e.g., ",(0,o.jsx)(s.code,{children:"Trigger.Request"}),") that might contain object ID or grasping parameters."]}),"\n",(0,o.jsxs)(s.li,{children:["The ",(0,o.jsx)(s.code,{children:"gripper_control_node"})," executes the complex grasping motion."]}),"\n",(0,o.jsxs)(s.li,{children:["Once the motion is complete, it sends a response back to the ",(0,o.jsx)(s.code,{children:"high_level_planner_node"})," (e.g., ",(0,o.jsx)(s.code,{children:"Trigger.Response"})," with a success/failure status and perhaps a message)."]}),"\n",(0,o.jsxs)(s.li,{children:["The ",(0,o.jsx)(s.code,{children:"high_level_planner_node"})," then continues its planning based on the service response."]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.strong,{children:"Controls and Best Practices for Services:"})}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Service Design:"})," Design services for discrete, one-time actions. Avoid using services for continuous data streams or tasks that might take a very long time, as clients will block while waiting."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Error Handling:"})," Implement robust error handling in both the service server (to define appropriate failure responses) and the client (to handle timeouts or failed requests)."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Introspection:"})," Use ",(0,o.jsx)(s.code,{children:"ros2 service list"}),", ",(0,o.jsx)(s.code,{children:"ros2 service type <service_name>"}),", and ",(0,o.jsx)(s.code,{children:"ros2 service call <service_name> <service_type> <request_args>"})," to inspect and interact with services from the command line."]}),"\n"]}),"\n",(0,o.jsx)(s.h3,{id:"214-beyond-basics-actions-goal-based-asynchronous-tasks",children:"2.1.4 Beyond Basics: Actions (Goal-Based Asynchronous Tasks)"}),"\n",(0,o.jsxs)(s.p,{children:["While Topics and Services cover a broad range of communication needs, ROS 2 also introduces ",(0,o.jsx)(s.strong,{children:"Actions"}),". Actions are designed for long-running, goal-based tasks that require periodic feedback and the ability to be preempted."]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"When to Use Actions:"}),' Think of navigation to a distant goal, charging a battery, or a complex pick-and-place sequence. These tasks take time, provide intermediate feedback (e.g., "progress: 50%"), and might need to be canceled.']}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Structure:"})," An Action consists of:","\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Goal:"})," The desired outcome (e.g., target pose for navigation)."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Result:"})," The final outcome (e.g., ",(0,o.jsx)(s.code,{children:"reached_goal: true"}),")."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Feedback:"})," Continuous updates on the progress (e.g., ",(0,o.jsx)(s.code,{children:"current_pose"}),", ",(0,o.jsx)(s.code,{children:"distance_to_goal"}),")."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Client-Server Model:"})," Similar to services, but with explicit feedback and preemption capabilities."]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.strong,{children:"Further Research: ROS 2 Actions"})}),"\n",(0,o.jsx)(s.p,{children:"Explore the official ROS 2 documentation on Actions to understand their structure, how to define custom action messages, and implement simple action servers and clients. Understanding when to choose between Topics, Services, and Actions is a key skill in advanced ROS 2 development."}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.strong,{children:"Project: Robot Arm Task Delegation (Topics, Services, & Actions Combined)"})}),"\n",(0,o.jsx)(s.p,{children:"Building on your practice of designing nodes for a humanoid arm, let's refine the communication architecture by incorporating Actions:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Joint State Publishing (Topic):"})," The ",(0,o.jsx)(s.code,{children:"joint_state_publisher_node"})," continuously publishes the robot arm's current joint angles and velocities to ",(0,o.jsx)(s.code,{children:"/robot_arm/joint_states"})," topic."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Emergency Stop (Service):"})," A ",(0,o.jsx)(s.code,{children:"safety_monitor_node"})," provides an ",(0,o.jsx)(s.code,{children:"/robot_arm/emergency_stop"})," service. When called, it immediately brings the arm to a safe halt and responds with a ",(0,o.jsx)(s.code,{children:"success: true"})," or ",(0,o.jsx)(s.code,{children:"false"}),"."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Complex Manipulation (Action):"})," A ",(0,o.jsx)(s.code,{children:"manipulation_action_server_node"})," offers a ",(0,o.jsx)(s.code,{children:"/robot_arm/execute_manipulation"})," action.","\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Goal:"})," A request to move the arm to a specific target pose while performing a grasp."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Feedback:"}),' Periodically publishes the arm\'s current progress (e.g., "moving to pre-grasp pose", "grasping object").']}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Result:"})," Reports ",(0,o.jsx)(s.code,{children:"success: true"})," / ",(0,o.jsx)(s.code,{children:"false"})," and any relevant information (e.g., ",(0,o.jsx)(s.code,{children:"object_grasped_id"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.p,{children:["Describe the message types you would define for the action goal, result, and feedback. Explain how a ",(0,o.jsx)(s.code,{children:"high_level_planner_node"})," would interact with these components to perform a complete pick-and-place operation, including how it would handle potential issues (e.g., calling the emergency stop service if a problem is detected during the manipulation action)."]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>c});var i=n(6540);const o={},r=i.createContext(o);function t(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);