"use strict";(globalThis.webpackChunkbook_source=globalThis.webpackChunkbook_source||[]).push([[6219],{1822:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Module 05 Humanoid-Walking/5.4-humanoid-zmp-calculation-example","title":"5.4: Humanoid Locomotion - ZMP Calculation Example","description":"Building upon the theoretical understanding of the Zero Moment Point (ZMP), this section provides a conceptual code snippet and an extended practice exercise for calculating a simplified ZMP. Understanding this calculation is fundamental for implementing stable bipedal locomotion control strategies.","source":"@site/docs/Module 05 Humanoid-Walking/5.4-humanoid-zmp-calculation-example.md","sourceDirName":"Module 05 Humanoid-Walking","slug":"/Module 05 Humanoid-Walking/5.4-humanoid-zmp-calculation-example","permalink":"/docs/Module 05 Humanoid-Walking/5.4-humanoid-zmp-calculation-example","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Module 05 Humanoid-Walking/5.4-humanoid-zmp-calculation-example.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"5.3: Humanoid Locomotion - Static vs. Dynamic Walking","permalink":"/docs/Module 05 Humanoid-Walking/5.3-humanoid-static-dynamic-walking"},"next":{"title":"Chapter 6: Navigation & SLAM - SLAM Fundamentals","permalink":"/docs/Module 06 Navigation-SLAM/6.1-slam-fundamentals"}}');var r=n(4848),i=n(8453);const a={},s="5.4: Humanoid Locomotion - ZMP Calculation Example",l={},c=[{value:"4. Code Concept: Simple <code>calculate_zmp(force_sensors)</code> Function",id:"4-code-concept-simple-calculate_zmpforce_sensors-function",level:2},{value:"Python Snippet: Simplified Single Foot ZMP Calculation",id:"python-snippet-simplified-single-foot-zmp-calculation",level:3},{value:"Extended Practice: Bipedal ZMP Integration",id:"extended-practice-bipedal-zmp-integration",level:3}];function d(e){const o={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(o.header,{children:(0,r.jsx)(o.h1,{id:"54-humanoid-locomotion---zmp-calculation-example",children:"5.4: Humanoid Locomotion - ZMP Calculation Example"})}),"\n",(0,r.jsx)(o.p,{children:"Building upon the theoretical understanding of the Zero Moment Point (ZMP), this section provides a conceptual code snippet and an extended practice exercise for calculating a simplified ZMP. Understanding this calculation is fundamental for implementing stable bipedal locomotion control strategies."}),"\n",(0,r.jsxs)(o.h2,{id:"4-code-concept-simple-calculate_zmpforce_sensors-function",children:["4. Code Concept: Simple ",(0,r.jsx)(o.code,{children:"calculate_zmp(force_sensors)"})," Function"]}),"\n",(0,r.jsx)(o.p,{children:"Calculating the ZMP in a real robot typically involves integrating force/torque sensor data from the feet, along with inertial measurements from IMUs and kinematic data from joint encoders. For a simplified conceptual understanding, consider a robot with force sensors at various points on its feet. The ZMP can be approximated by a weighted average of the force sensor locations, where the weights are the normal forces measured by each sensor."}),"\n",(0,r.jsx)(o.h3,{id:"python-snippet-simplified-single-foot-zmp-calculation",children:"Python Snippet: Simplified Single Foot ZMP Calculation"}),"\n",(0,r.jsxs)(o.p,{children:["Here's a basic Python snippet to illustrate this concept for a single foot, assuming an array of ",(0,r.jsx)(o.code,{children:"force_sensors"}),", each providing ",(0,r.jsx)(o.code,{children:"(x_pos, y_pos, normal_force)"}),":"]}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-python",children:'import numpy as np\r\n\r\ndef calculate_zmp_simplified_single_foot(force_sensors):\r\n    """\r\n    Calculates a simplified Zero Moment Point (ZMP) for a single foot\r\n    based on force sensor readings.\r\n\r\n    Args:\r\n        force_sensors (list): A list of tuples, where each tuple represents\r\n                              a force sensor reading: (x_position, y_position, normal_force).\r\n                              x_position and y_position are relative to the foot\'s origin (e.g., center).\r\n\r\n    Returns:\r\n        tuple: (zmp_x, zmp_y) coordinates if total_force > 0, otherwise (0.0, 0.0).\r\n    """\r\n    total_force_x_moment = 0.0\r\n    total_force_y_moment = 0.0\r\n    total_normal_force = 0.0\r\n\r\n    for x_pos, y_pos, normal_force in force_sensors:\r\n        total_force_x_moment += x_pos * normal_force\r\n        total_force_y_moment += y_pos * normal_force\r\n        total_normal_force += normal_force\r\n\r\n    if total_normal_force > 0:\r\n        zmp_x = total_force_x_moment / total_normal_force\r\n        zmp_y = total_force_y_moment / total_normal_force\r\n        return zmp_x, zmp_y\r\n    else:\r\n        # If no force is detected (foot is in the air), ZMP is undefined.\r\n        # Returning (0.0, 0.0) is a common convention for such cases or when ZMP is outside the foot.\r\n        return 0.0, 0.0\r\n\r\n# Example Usage:\r\n# Assuming force sensors at corners of a rectangular foot, relative to the foot\'s center.\r\n# Sensor positions in meters: Front-left (-0.05, 0.08), Front-right (0.05, 0.08),\r\n# Rear-left (-0.05, -0.08), Rear-right (0.05, -0.08).\r\n\r\n# Scenario 1: Evenly distributed force, ZMP near center\r\nprint("\\n--- Scenario 1: Evenly Distributed Force ---")\r\nsensor_data_foot_1 = [\r\n    (-0.05, 0.08, 10.0),  # Front-left sensor: (x, y, force_z)\r\n    (0.05, 0.08, 12.0),   # Front-right sensor\r\n    (-0.05, -0.08, 15.0), # Rear-left sensor\r\n    (0.05, -0.08, 13.0)    # Rear-right sensor\r\n]\r\nzmp_x_foot1, zmp_y_foot1 = calculate_zmp_simplified_single_foot(sensor_data_foot_1)\r\nprint(f"Simplified ZMP for foot 1: ({zmp_x_foot1:.4f}, {zmp_y_foot1:.4f}) meters")\r\n\r\n# Scenario 2: Force shifted towards the front, ZMP shifts forward\r\nprint("\\n--- Scenario 2: Force Shifted Forward ---")\r\nsensor_data_foot_2 = [\r\n    (-0.05, 0.08, 20.0),  # Higher force on front sensors\r\n    (0.05, 0.08, 22.0),\r\n    (-0.05, -0.08, 5.0),\r\n    (0.05, -0.08, 6.0)\r\n]\r\nzmp_x_foot2, zmp_y_foot2 = calculate_zmp_simplified_single_foot(sensor_data_foot_2)\r\nprint(f"Simplified ZMP for foot 2: ({zmp_x_foot2:.4f}, {zmp_y_foot2:.4f}) meters")\r\n\r\n# Scenario 3: No force, foot in air\r\nprint("\\n--- Scenario 3: No Force (Foot in Air) ---")\r\nsensor_data_foot_3 = [\r\n    (-0.05, 0.08, 0.0),\r\n    (0.05, 0.08, 0.0),\r\n    (-0.05, -0.08, 0.0),\r\n    (0.05, -0.08, 0.0)\r\n]\r\nzmp_x_foot3, zmp_y_foot3 = calculate_zmp_simplified_single_foot(sensor_data_foot_3)\r\nprint(f"Simplified ZMP for foot 3: ({zmp_x_foot3:.4f}, {zmp_y_foot3:.4f}) meters")\r\n\r\n# In a full bipedal system, you\'d combine ZMP calculations from both feet\r\n# during double support, and monitor the ZMP within the active support foot\r\n# during single support. The overall ZMP for the robot would be a more complex\r\n# calculation involving the entire robot\'s dynamics and all ground contact forces.\n'})}),"\n",(0,r.jsx)(o.h3,{id:"extended-practice-bipedal-zmp-integration",children:"Extended Practice: Bipedal ZMP Integration"}),"\n",(0,r.jsxs)(o.p,{children:[(0,r.jsx)(o.strong,{children:"Goal:"})," Expand the simplified ",(0,r.jsx)(o.code,{children:"calculate_zmp_simplified_single_foot"})," function to conceptually handle a bipedal robot with two feet during both single and double support phases. This will deepen your understanding of how ZMP is managed during a full gait cycle."]}),"\n",(0,r.jsxs)(o.ol,{children:["\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Define Two Feet:"})," Assume you have ",(0,r.jsx)(o.code,{children:"sensor_data_left_foot"})," and ",(0,r.jsx)(o.code,{children:"sensor_data_right_foot"}),", similar in structure to the ",(0,r.jsx)(o.code,{children:"sensor_data_foot_1"})," example."]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsxs)(o.strong,{children:[(0,r.jsx)(o.code,{children:"calculate_bipedal_zmp"})," Function:"]})," Create a new function, ",(0,r.jsx)(o.code,{children:"calculate_bipedal_zmp(left_foot_sensors, right_foot_sensors)"}),". This function should:","\n",(0,r.jsxs)(o.ul,{children:["\n",(0,r.jsxs)(o.li,{children:["First, calculate the ZMP for each individual foot using ",(0,r.jsx)(o.code,{children:"calculate_zmp_simplified_single_foot"}),"."]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Double Support Phase:"})," If both feet have ",(0,r.jsx)(o.code,{children:"total_normal_force > 0"}),", calculate the overall robot ZMP as the weighted average of the two individual foot ZMPs. The weights could be the ",(0,r.jsx)(o.code,{children:"total_normal_force"})," of each foot. This will place the overall ZMP somewhere between the two feet."]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Single Support Phase:"})," If only one foot has ",(0,r.jsx)(o.code,{children:"total_normal_force > 0"}),", the robot's overall ZMP is simply the ZMP of the supporting foot."]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"No Support:"})," If neither foot has ",(0,r.jsx)(o.code,{children:"total_normal_force > 0"}),", return (0.0, 0.0) as the robot is falling."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Test Scenarios:"})," Create test data for:","\n",(0,r.jsxs)(o.ul,{children:["\n",(0,r.jsx)(o.li,{children:"Both feet on the ground (double support, CoM centered)."}),"\n",(0,r.jsx)(o.li,{children:"Both feet on the ground, CoM shifted towards one foot."}),"\n",(0,r.jsx)(o.li,{children:"Only left foot on the ground (single support)."}),"\n",(0,r.jsx)(o.li,{children:"Only right foot on the ground (single support)."}),"\n",(0,r.jsx)(o.li,{children:"Neither foot on the ground (mid-air or falling)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Visualize (Conceptual):"})," Mentally (or with simple print statements) trace the ZMP's path through these scenarios, noting how it stays within the support polygon during stable phases."]}),"\n"]}),"\n",(0,r.jsx)(o.p,{children:"This exercise will help you grasp the dynamic nature of ZMP control and how it changes across different phases of bipedal locomotion, forming a crucial foundation for more advanced control algorithms."})]})}function p(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,r.jsx)(o,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>a,x:()=>s});var t=n(6540);const r={},i=t.createContext(r);function a(e){const o=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function s(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:o},e.children)}}}]);